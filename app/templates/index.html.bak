<!DOCTYPE html>
<html>
<head>
    <title>Word Train Webapp</title>
    <link rel="stylesheet" type="text/css" href="{{ url_for('static', filename='style.css') }}">
    <style>
        /* Keep existing styles from style.css or other <style> blocks */

        /* --- MODIFIED CSS --- */
        .definition-container {
            position: fixed;        /* Fix position relative to viewport */
            bottom: 0;              /* Stick to the bottom */
            left: 0;                /* Align to the left */
            width: 100%;            /* Take full width */
            box-sizing: border-box; /* Include padding in width calculation */

            padding: 5px 15px;      /* Reduced padding (smaller) */
            background-color: #f0f0f0; /* Slightly different bg */
            border-top: 3px solid #3498db; /* Border on top now */
            font-style: italic;
            font-size: 0.9em;       /* Smaller font size */
            z-index: 100;           /* Ensure it stays above other content */
            text-align: center;     /* Center the text inside */

            /* Removed properties related to in-flow positioning: */
            /* margin-top: 10px; */
            /* border-radius: 8px; */ /* Might look odd on a full-width bar */
            /* border-left: 4px solid #3498db; */
            /* max-width: 90%; */
            /* margin-left: auto; */
            /* margin-right: auto; */
        }
        /* Add some bottom padding to the body so content isn't hidden */
        body {
            padding-bottom: 50px; /* Adjust height based on definition container */
        }
        /* --- END OF MODIFIED CSS --- */
    </style>
</head>
<body>
    <h1>üöÇ Word Train Generator</h1>
    <form method="POST" id="train-form">
        <input type="text" name="word" placeholder="Enter word(s)" required autofocus>
        <select name="engine">
            <option value="üöÇ">üöÇ Classic</option>
            <option value="üöÄ">üöÄ Rocket</option>
            <option value="üõ∏">üõ∏ UFO</option>
            <option value="üöå">üöå Bus</option>
            <option value="üêç">üêç Snake</option>
        </select>
        <label for="speed">Speed:</label>
        <input type="range" name="speed" min="5" max="30" value="{{ speed if speed else 12 }}">
        <button type="submit">Generate Train</button>
        <button type="button" id="random-word-btn" class="generate-style">üé≤ Random Word</button>
    </form>

    <div class="challenge">üéØ Try to match the challenge word: <strong>{{ challenge_word }}</strong></div>

    <div id="train-output-area">
        {% if message %}
        <div class="message">{{ message }}</div>
        {% endif %}

        {% if output %}
        <div class="output">
            <h2>Your Trains:</h2>
            {% for train in output %}
            <div class="train-block">
                <div class="train-container">
                    <div class="train-row">
                        <div class="train-output">{{ train | safe }}</div>
                    </div>
                </div>
                <div class="wheels-row">
                    {% for _ in range(train|length // 2) %}
                    <svg class="wheel" viewBox="0 0 40 40">
                        <circle cx="20" cy="20" r="16" stroke="black" stroke-width="3" fill="gray" />
                        <line x1="20" y1="4" x2="20" y2="36" stroke="black" stroke-width="2" />
                        <line x1="4" y1="20" x2="36" y2="20" stroke="black" stroke-width="2" />
                    </svg>
                    {% endfor %}
                </div>
                <div class="rails">
                    <svg width="100%" height="20">
                        <rect x="0" y="10" width="100%" height="4" fill="#444" />
                        <line x1="0" y1="10" x2="100%" y2="10" stroke="#777" stroke-width="2" stroke-dasharray="10, 10" />
                    </svg>
                </div>
                </div>
            {% endfor %}
        </div>
        {% endif %}
    </div>

    <div class="definition-container" id="definition-area">Enter a word to see its definition!</div>

<script>
document.addEventListener("DOMContentLoaded", () => {
    console.log("DOMContentLoaded event fired."); // Log when script starts after load

    const slider = document.querySelector('input[name="speed"]');
    const inputField = document.querySelector('input[name="word"]');
    const randomButton = document.getElementById('random-word-btn');
    const form = document.getElementById('train-form');
    const definitionContainer = document.getElementById('definition-area');

    if (!definitionContainer) {
        console.error("ERROR: Definition container not found!");
        return; // Stop if critical element is missing
    }
    console.log("Definition container found:", definitionContainer);

    // --- Speed slider ---
    slider.addEventListener('input', () => {
        // ... (slider code remains the same) ...
    });

    // --- Enter key submit ---
    inputField.addEventListener('keydown', function (event) {
       // ... (keydown code remains the same) ...
    });

    // --- FORM SUBMIT (causes page reload) ---
    form.addEventListener('submit', function() {
        const wordToSubmit = inputField.value.trim();
        console.log("Form submitted. Saving to localStorage:", wordToSubmit); // Log before reload
        localStorage.setItem('lastWord', wordToSubmit);
        // Allow normal POST submission and page reload
    });

    // --- AFTER PAGE LOAD ---
    const lastWord = localStorage.getItem('lastWord');
    console.log("After page load, retrieved from localStorage:", lastWord); // Log word retrieved

    if (lastWord && definitionContainer) {
        console.log(`Attempting to get definition for "${lastWord}" on page load.`); // Log before fetch
        definitionContainer.innerHTML = `<i>Loading definition for "${lastWord}"...</i>`;
        getDefinition(lastWord)
            .then(definition => {
                console.log(`Definition received for "${lastWord}":`, definition); // Log definition received
                 // Double-check container exists before updating
                const currentDefinitionContainer = document.getElementById('definition-area');
                if (currentDefinitionContainer) {
                     console.log("Updating definition container HTML."); // Log before update
                     currentDefinitionContainer.innerHTML = definition;
                } else {
                     console.error("Definition container disappeared before update!");
                }
            })
            .catch(error => {
                // Catch errors specifically from the getDefinition promise
                console.error(`Error fetching definition for "${lastWord}" on page load:`, error);
                if (definitionContainer) {
                     definitionContainer.innerHTML = `Failed to load definition for "${lastWord}".`;
                }
            });
    } else if (definitionContainer) {
        console.log("No lastWord found in localStorage, setting default message."); // Log default case
        definitionContainer.innerHTML = "Enter a word to see its definition!";
    } else {
        console.log("No lastWord in localStorage AND definition container missing.");
    }


    // --- Random word generator function (async generateRandomWord) ---
    async function generateRandomWord() {
        // ... (keep existing function code) ...
         try {
            const response = await fetch('https://random-word-api.herokuapp.com/word');
            // console.log("Fetch response:", response); // Optional: less noisy
            if (!response.ok) throw new Error(`Network response was not ok (${response.status})`);
            const data = await response.json();
            if (!data || !data[0]) throw new Error("Invalid data received from random word API");
            console.log("Received random word:", data[0]);
            return data[0];
        } catch (error) {
            console.error("Random Word Fetch error:", error);
            const fallbackWords = ["Train", "Journey", "Adventure", "Express", "Locomotive", "Railroad", "Voyage", "Expedition", "Travel", "Destination", "Passenger", "Conductor", "Station", "Track", "Wheels"];
            const randomWord = fallbackWords[Math.floor(Math.random() * fallbackWords.length)];
            console.log("Using fallback word:", randomWord);
            return randomWord;
        }
    }

    // --- Dictionary API function (async getDefinition) ---
 // --- Dictionary API function (async getDefinition) ---
    async function getDefinition(word) {
        console.log(`Inside getDefinition, looking up: "${word}"`);
        try {
            if (!word) return "Enter a word to see its definition!"; // Handles empty input early

            const cleanWord = word.split(/\s+/)[0].toLowerCase().replace(/[^a-z]/g, '');
            if (!cleanWord) {
                console.log(`Cleaned word is empty for input: "${word}"`);
                return "Maybe try entering... you know... actual letters? üòâ"; // Funny fallback for invalid input
            }
            console.log(`Cleaned word for API call: "${cleanWord}"`);

            const response = await fetch(`https://api.dictionaryapi.dev/api/v2/entries/en/${cleanWord}`);
            console.log(`Dictionary API response status for "${cleanWord}": ${response.status}`);

            // --- CASE 1: API Responded, but Word Not Found (or other API error) ---
            if (!response.ok) {
                 // Keep your existing funny list for "word not found"
                 const wordNotFoundResponses = [
                    `"${word}"? I looked everywhere but couldn't find this word! üïµÔ∏è‚Äç‚ôÇÔ∏è`,
                    `Ah! Do you speak the language of the ancients? "${word}" is a mystery to me! üßô‚Äç‚ôÇÔ∏è`,
                    `Hmm, "${word}" sounds made up. But then again, aren't all words? ü§î`,
                    `I tried asking my dictionary friends about "${word}", but they just laughed! üìö`,
                    `"${word}" - Is that from a sci-fi novel or did you just sneeze? ü§ß`,
                    `My dictionary threw a 404 error page at me for "${word}". Rude! üìÑ`,
                    `Is "${word}" even legal in Scrabble? Doesn't look like it's in my dictionary!`
                ];
                console.warn(`Dictionary API non-OK response for "${cleanWord}": ${response.status}.`);
                // Select a random response from this list
                return wordNotFoundResponses[Math.floor(Math.random() * wordNotFoundResponses.length)];
            }

            // --- CASE 2: API Responded Successfully (status 2xx) ---
            const data = await response.json();
            const meanings = data[0]?.meanings;

            if (meanings && meanings.length > 0 && meanings[0].definitions && meanings[0].definitions.length > 0) {
                const partOfSpeech = meanings[0].partOfSpeech || 'unknown';
                const definition = meanings[0].definitions[0].definition;
                console.log(`Successfully found definition for "${cleanWord}"`);
                return `<strong>${cleanWord}</strong> <em>(${partOfSpeech})</em>: ${definition}`;
            } else {
                // This case means API gave 200 OK, but data structure was unexpected/empty
                console.warn(`Found "${cleanWord}" but structure missing meanings/definitions. Data:`, data);
                 // Add a funny fallback here too, if you like
                 const weirdDataResponses = [
                     `Found "${cleanWord}" but the definition seems to have wandered off... üö∂‚Äç‚ôÇÔ∏è`,
                     `The entry for "${cleanWord}" exists, but it's written in invisible ink! ‚ú®`,
                     `"${cleanWord}" is in the dictionary, but the definition is playing hide-and-seek! üôà`
                 ];
                return weirdDataResponses[Math.floor(Math.random() * weirdDataResponses.length)];
            }

        // --- CASE 3: Failed to Fetch (Network error, API down, CORS, etc.) ---
        } catch (error) {
            console.error(`General error in getDefinition for "${word}":`, error); // Keep logging the real error for debugging

             // NEW funny list for connection/fetch errors
             const connectionErrorResponses = [
                `Is the dictionary API napping? üò¥ Couldn't get a definition for "${word}".`,
                `My wires must be crossed! ‚ö°Ô∏è Failed to look up "${word}". Try again?`,
                `The definition gnomes are on strike! ‚úä Couldn't fetch "${word}".`,
                `Uh oh, hit some turbulence trying to fetch "${word}". ‚úàÔ∏è Maybe try again later?`,
                `The dictionary server might be lost in translation... üåê Error fetching "${word}".`,
                `Whoops! Dropped the dictionary while looking up "${word}". üìö Try again!`,
                `Static electricity? Gremlins? üëæ Couldn't connect to fetch "${word}".`,
                `Does the internet exist right now? ü§î Couldn't reach the dictionary for "${word}".`
             ];
            // Select a random response from this new list
            return connectionErrorResponses[Math.floor(Math.random() * connectionErrorResponses.length)];
        }
    }
    // --- AJAX FOR RANDOM WORD ---
    randomButton.addEventListener('click', async () => {
        console.log("Random Word button clicked.");
        showPopup();
        if (definitionContainer) {
            definitionContainer.innerHTML = "<i>Generating random word...</i>";
        }

        const randomWord = await generateRandomWord();
        console.log(`Generated random word: "${randomWord}". Storing to localStorage.`);
        localStorage.setItem('lastWord', randomWord); // Also store random word

        const formData = new FormData(form);
        formData.set("word", randomWord);

        console.log("Starting AJAX fetch for random word train...");
        fetch("/", { method: "POST", body: formData })
            .then(response => {
                console.log(`AJAX response status: ${response.status}`);
                if (!response.ok) throw new Error(`AJAX POST failed with status ${response.status}`);
                return response.text();
            })
            .then(html => {
                console.log("AJAX HTML received. Parsing...");
                const parser = new DOMParser();
                const doc = parser.parseFromString(html, "text/html");
                const newOutput = doc.querySelector("#train-output-area");
                const currentOutputArea = document.querySelector("#train-output-area");

                if (newOutput && currentOutputArea) {
                    console.log("Replacing #train-output-area content.");
                    currentOutputArea.innerHTML = newOutput.innerHTML;

                    // Now update definition for the *random* word
                    const currentDefinitionContainer = document.getElementById('definition-area'); // Re-select after potential DOM change
                    if (currentDefinitionContainer) {
                         console.log(`Attempting AJAX definition fetch for "${randomWord}"`);
                         currentDefinitionContainer.innerHTML = `<i>Loading definition for "${randomWord}"...</i>`;
                         getDefinition(randomWord).then(definition => {
                            console.log(`AJAX definition received for "${randomWord}"`);
                             if(currentDefinitionContainer) { // Check again
                                currentDefinitionContainer.innerHTML = definition;
                             }
                         }).catch(error => {
                              console.error(`Error fetching definition for "${randomWord}" via AJAX:`, error);
                              if (currentDefinitionContainer) {
                                   currentDefinitionContainer.innerHTML = `Failed to load definition for "${randomWord}".`;
                              }
                         });
                    } else {
                         console.error("Definition container not found after AJAX update!");
                    }
                } else {
                     console.error("Could not find #train-output-area in AJAX response or current page.");
                }

                inputField.value = randomWord;
                inputField.focus();
                console.log("AJAX update complete.");
            })
            .catch(error => {
                 console.error("Error during AJAX fetch/processing:", error);
                 // Optionally display error to user
                 if(definitionContainer) definitionContainer.innerHTML = "Error loading new train.";
            });
    });

}); // End DOMContentLoaded


// --- Popup function (showPopup) ---
function showPopup() {
    // ... (keep existing function code) ...
}
</script>
</body>
